---
title: Streaming Radio
permalink: /radio1/
image: 'https://marzorati.co/img/music.png'
share-img: 'https://marzorati.co/img/music.png'
date: 2025-06-04 07:00:00 +0200
author: Stefano Marzorati
layout: page
bigimg: ['https://marzorati.co/img/post/music_1.jpeg', 'https://marzorati.co/img/post/music_4.png']
categories: [Music]
tags: [radio, web, streaming, mp3, m3u8, m2o, gabber, frenchcore, techno, jazz, pop]
---

<style>
:root {
  --accent: #4A90E2;
  --border: #000;
  --bg: #f9f9f9;
  --radius: .75em;
  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
}

.radio-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-family: var(--font);
  gap: 1rem;
  margin-bottom: 2rem;
  padding: 0 1rem;
}

label[for="radio-select"] {
  font: 700 1.75rem/1.1 var(--font);
  margin-top: .25rem;
  text-align: center;
}

#radio-select {
  font-size: 1.1rem;
  padding: .75em 1.2em;
  border: 2px solid #111;
  border-radius: var(--radius);
  background: var(--bg) url("data:image/svg+xml,%3Csvg fill='gray' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E") right .8em center / 1em no-repeat;
  appearance: none;
  min-width: 260px;
  max-width: min(90vw, 740px);
  text-align: center;
  text-align-last: center;
  outline: none;
  transition: border .2s, box-shadow .2s, transform .05s;
}
#radio-select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 4px rgba(74,144,226,.15);
}
#radio-select:active { transform: scale(.997); }

.player-card {
  width: 100%;
  max-width: 1100px;
  border: 3px solid var(--border);
  border-radius: 1rem;
  background: #fff;
  box-shadow: 0 10px 30px rgba(0,0,0,.08);
  overflow: clip;
}

.player-top {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: .75rem;
  padding: 1rem 1rem .5rem 1rem;
}

#play-pause {
  width: 3rem;
  height: 3rem;
  border: 3px solid var(--border);
  border-radius: 50%;
  background: #fff;
  cursor: pointer;
  transition: .2s;
  display: grid;
  place-items: center;
}
#play-pause:hover:enabled { background: #f3f3f3; transform: translateY(-1px); }
#play-pause:active:enabled { transform: translateY(0); }
#play-pause:disabled { opacity: .5; cursor: not-allowed; }

.meta {
  display: flex;
  flex-direction: column;
  min-width: 0;
}
.meta .title {
  font-weight: 700;
  font-size: 1.05rem;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.meta .subtitle {
  font-size: .9rem;
  color: #555;
}

.controls {
  display: flex;
  align-items: center;
  gap: .75rem;
}
.range-row {
  display: flex;
  align-items: center;
  gap: .5rem;
}
.range-row input[type="range"] {
  width: min(42vw, 240px);
}
.icon {
  width: 1.2rem; height: 1.2rem; display: inline-block;
}

.bar {
  height: 8px;
  width: 100%;
  appearance: none;
  background: #eee;
  border: none;
  border-radius: 6px;
}
.bar::-webkit-slider-runnable-track { height: 8px; background:#eee; border-radius:6px; }
.bar::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  width: 16px; height: 16px; border-radius: 50%;
  background: #111; margin-top: -4px; border: 2px solid white; box-shadow: 0 0 0 2px #111 inset;
}
.bar::-moz-range-track { height: 8px; background:#eee; border-radius:6px; }
.bar::-moz-range-thumb {
  width: 16px; height: 16px; border-radius: 50%;
  background: #111; border: 2px solid white; box-shadow: 0 0 0 2px #111 inset;
}

.vis-wrap {
  width: 100%;
  background: linear-gradient(180deg, #fbfbfb, #f4f4f4);
  border-top: 3px solid var(--border);
  border-bottom: 3px solid var(--border);
  position: relative;
}
#visualizer {
  width: 100%;
  display: block;
  height: clamp(160px, 33vw, 380px);
  background:
    radial-gradient(1200px 300px at 50% -100px, rgba(74,144,226,0.12), transparent 60%),
    linear-gradient(180deg, #ffffff, #fafafa);
}
.vis-overlay {
  position: absolute; inset: 0;
  pointer-events: none;
  background:
    linear-gradient(180deg, rgba(0,0,0,0.04), rgba(0,0,0,0) 40%, rgba(0,0,0,0) 60%, rgba(0,0,0,0.05)),
    repeating-linear-gradient(90deg, rgba(0,0,0,.03) 0 1px, transparent 1px 32px);
}

.badge {
  font-size: .85rem;
  color: #333;
  background: #fff7cc;
  border: 1px solid #f2d369;
  padding: .4rem .6rem;
  border-radius: .5rem;
  display: inline-flex;
  align-items: center;
  gap: .4rem;
}

.footer-row {
  display: flex;
  align-items: center;
  gap: .75rem;
  justify-content: space-between;
  padding: .6rem 1rem 1rem 1rem;
  flex-wrap: wrap;
}
.now {
  font-size: .9rem;
  color: #666;
}

@media (max-width: 720px) {
  .player-top { grid-template-columns: auto 1fr; }
  .controls { grid-column: 1 / -1; justify-content: space-between; }
}

@media (prefers-reduced-motion: reduce) {
  #visualizer { transition: none !important; }
}
</style>

<div class="radio-wrapper">
  <label for="radio-select">Scegli una radio</label>
  <select id="radio-select">
    <option value="" disabled selected>— seleziona —</option>
    <option value="https://4c4b867c89244861ac216426883d1ad0.msvdn.net/radiom2obck/radiom2obck/play1.m3u8">M2O</option>
    <option value="https://22333.live.streamtheworld.com/TLPSTR16.mp3?dist=538_web">538 Party Zone</option>
    <option value="https://stream1-0nlineradio.radiohost.de/trending-charts?ref=tiny">0nlineradio</option>
    <option value="https://free.rcast.net/213024">Radio Party .pl</option>
    <option value="https://stream.technolovers.fm/gabber">Gabber</option>
    <option value="https://listen5.myradio24.com/eugenijus">Eugenijus Radio</option>
    <option value="https://a8.asurahosting.com:7890/radio.mp3">Frenchcore24FM</option>
    <option value="https://regiocast.streamabc.net/regc-90s90stechno2195701-mp3-192-2408420">90s 90s Techno</option>
    <option value="https://4c4b867c89244861ac216426883d1ad0.msvdn.net/radiodeejaybck/radiodeejaybck/play1.m3u8">Radio Deejay</option>
    <option value="https://4c4b867c89244861ac216426883d1ad0.msvdn.net/radiodeejay30songsbck/radiodeejay30songsbck/play1.m3u8">30 Songs - Deejay</option>
    <option value="https://vdnvsxa1-4c4b867c89244861ac216426883d1ad0.msvdn.net/webradio/deejaytime/live.m3u8">Deejay Time</option>
    <option value="https://stream.discoradio.radio/audio/disco.stream_aac64/chunklist.m3u8">Disco Radio</option>
    <option value="https://nr15.newradio.it:9100/stream">R.I.N.</option>
    <option value="https://regiocast.streamabc.net/regc-80s80smweb2517500-mp3-192-1672667">80s 80s</option>
    <option value="https://regiocast.streamabc.net/regc-80s80stechno-mp3-192-6907852">80s 80s Techno</option>
    <option value="https://nr8.newradio.it:19574/stream">70/80 Hits</option>
    <option value="https://smoothjazz.cdnstream1.com/2585_128.mp3">Smooth Jazz</option>
    <option value="https://ilsole24ore-radio.akamaized.net/hls/live/2035301/radio24/playlist-48000.m3u8">Il Sole 24 ore</option>
  </select>

  <div class="player-card" id="player-card">
    <div class="player-top">
      <button id="play-pause" aria-label="Play / Pause" disabled>
        <svg class="icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <polygon points="5,3 19,12 5,21"/>
        </svg>
      </button>
      <div class="meta">
        <div class="title" id="station-title">Nessuna radio selezionata</div>
        <div class="subtitle" id="station-url">—</div>
      </div>
      <div class="controls">
        <div class="range-row" title="Volume">
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 10v4h4l5 4V6L7 10H3z"/></svg>
          <input id="volume" type="range" min="0" max="1" step="0.01" value="0.9" class="bar" />
        </div>
        <div class="range-row" title="Bilanciamento bassi / alti (post-analisi)">
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 18h6v-2H3v2zm0-5h12v-2H3v2zm0-7v2h18V6H3z"/></svg>
          <input id="tilt" type="range" min="-1" max="1" step="0.01" value="0" class="bar" />
        </div>
      </div>
    </div>

    <div class="vis-wrap">
      <canvas id="visualizer"></canvas>
      <div class="vis-overlay"></div>
    </div>

    <div class="footer-row">
      <span id="notice" class="badge" style="display:none;">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
        Visualizer limitato (CORS)
      </span>
      <span class="now" id="now">In pausa</span>
    </div>
  </div>

  <audio id="audio-player" preload="auto" crossorigin="anonymous"></audio>
</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
(() => {
  const audio      = document.getElementById('audio-player');
  const selector   = document.getElementById('radio-select');
  const playBtn    = document.getElementById('play-pause');
  const titleEl    = document.getElementById('station-title');
  const urlEl      = document.getElementById('station-url');
  const volEl      = document.getElementById('volume');
  const tiltEl     = document.getElementById('tilt');
  const nowEl      = document.getElementById('now');
  const noticeEl   = document.getElementById('notice');
  const canvas     = document.getElementById('visualizer');
  const ctx2d      = canvas.getContext('2d', { alpha: false, desynchronized: true });

  let hls = null;
  let isPlaying = false;

  // ===== Visualizer (Web Audio) =====
  let ac = null, source = null, analyser = null, gainNode = null, biquadTilt = null;
  const state = {
    bins: 96,               // numero barre responsive (si adatta poi con resize)
    fftSize: 2048,          // risoluzione spettro
    smoothing: 0.85,        // smoothing temporale
    peakHoldMs: 450,        // durata "cap" in ms
    peaks: [],              // peak caps per barra
    lastPeakTs: [],         // timestamp ultimo picco
    hasVisualizer: false,   // flag se Analyser attivo
    corsLimited: false      // fallback animazione se niente CORS
  };

  function resizeCanvas() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const { width } = canvas.getBoundingClientRect();
    const height = Math.max(160, Math.min(380, Math.round(width * 0.33)));
    canvas.width = Math.floor(width * dpr);
    canvas.height = Math.floor(height * dpr);
    canvas.style.height = height + 'px';
    canvas.style.width = Math.round(width) + 'px';
    ctx2d.setTransform(dpr, 0, 0, dpr, 0, 0);

    // calcola #barre in base alla larghezza (min 32, max 180)
    state.bins = Math.max(32, Math.min(180, Math.round(width / 8)));
    state.peaks = new Array(state.bins).fill(0);
    state.lastPeakTs = new Array(state.bins).fill(0);
  }

  const ro = new ResizeObserver(resizeCanvas);
  ro.observe(canvas);
  resizeCanvas();

  function setupAudioGraph() {
    if (!ac) {
      ac = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (source) { try { source.disconnect(); } catch {}
      source = null; }
    if (analyser) { try { analyser.disconnect(); } catch {}
      analyser = null; }
    if (gainNode) { try { gainNode.disconnect(); } catch {}
      gainNode = null; }
    if (biquadTilt) { try { biquadTilt.disconnect(); } catch {}
      biquadTilt = null; }

    // Collegamento WebAudio a <audio>. Può richiedere CORS sull'origine.
    try {
      source = ac.createMediaElementSource(audio);
      gainNode = ac.createGain();
      biquadTilt = ac.createBiquadFilter(); // usata come tilt semplice: shelving alte frequenze
      biquadTilt.type = "highshelf";
      biquadTilt.frequency.value = 2500; // punto di tilt
      biquadTilt.gain.value = 0;

      analyser = ac.createAnalyser();
      analyser.fftSize = state.fftSize;
      analyser.smoothingTimeConstant = state.smoothing;

      // catena
      source.connect(biquadTilt);
      biquadTilt.connect(gainNode);
      gainNode.connect(analyser);
      // IMPORTANTE: il suono deve anche arrivare alle casse
      gainNode.connect(ac.destination);

      state.hasVisualizer = true;
      state.corsLimited = false;
      noticeEl.style.display = 'none';
    } catch (e) {
      // Se fallisce (spesso per CORS), abilita fallback di animazione dummy
      state.hasVisualizer = false;
      state.corsLimited = true;
      noticeEl.style.display = 'inline-flex';
      // Assicura almeno audio -> destination
      try {
        audio.crossOrigin = "anonymous";
      } catch {}
    }
  }

  // Mappa indice barra -> indice bin FFT (log scale)
  function makeLogMap(fftSize, sampleRate, bins) {
    // usiamo solo metà spettro [0 .. N/2)
    const nyquist = sampleRate / 2;
    const minHz = 30;      // taglia rumore bassissimo
    const maxHz = Math.min(nyquist, 18000);
    const res = [];
    for (let i = 0; i < bins; i++) {
      const t = i / (bins - 1);
      const f = minHz * Math.pow(maxHz / minHz, t); // scala log
      const idx = Math.max(1, Math.min((fftSize / 2) - 1, Math.round(f / nyquist * (fftSize / 2))));
      res.push(idx);
    }
    return res;
  }

  let freqMap = null;
  function updateFreqMap() {
    if (ac && analyser) {
      freqMap = makeLogMap(analyser.fftSize, ac.sampleRate, state.bins);
    } else {
      freqMap = null;
    }
  }

  // Disegno visualizer
  const freqData = new Uint8Array(1024 * 16); // sovrabbondante, ridimensionato in run-time
  let rafId = 0, phase = 0;

  function draw() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx2d.clearRect(0, 0, w, h);

    const padX = 18;
    const padY = 12;
    const innerW = w - padX * 2;
    const innerH = h - padY * 2;
    const barW = innerW / state.bins;
    const gap = Math.max(1, Math.min(6, barW * 0.18));
    const usableBarW = barW - gap;

    // sfondo sottile
    ctx2d.fillStyle = '#fafafa';
    ctx2d.fillRect(0, 0, w, h);

    let values = new Array(state.bins).fill(0);

    if (state.hasVisualizer && analyser) {
      const specBins = analyser.frequencyBinCount;
      if (freqData.length < specBins) {
        // non dovrebbe accadere, ma nel dubbio
      }
      analyser.getByteFrequencyData(freqData);
      if (!freqMap || freqMap.length !== state.bins) updateFreqMap();

      // aggrega su log-map
      for (let i = 0; i < state.bins; i++) {
        const idx = freqMap[i];
        // finestra locale media su qualche bin adiacente per stabilità
        let sum = 0, count = 0;
        const span = 1 + Math.floor(i * 0.015); // finestra più ampia verso gli alti
        for (let k = -span; k <= span; k++) {
          const j = Math.max(1, Math.min(idx + k, specBins - 1));
          sum += freqData[j];
          count++;
        }
        const v = sum / count; // 0..255
        // compressione con curva soft (simil-log)
        const compressed = Math.pow(v / 255, 0.75);
        values[i] = compressed;
      }
    } else {
      // Fallback animazione se non possiamo analizzare (CORS)
      phase += 0.02;
      for (let i = 0; i < state.bins; i++) {
        const t = i / (state.bins - 1);
        const base = 0.25 + 0.15 * Math.sin(phase + t * 6.28);
        const wobble = 0.15 * Math.sin(phase * 2 + t * 14.0);
        values[i] = Math.max(0, Math.min(1, base + wobble));
      }
    }

    // Peak caps (hold & decay)
    const now = performance.now();
    for (let i = 0; i < state.bins; i++) {
      const v = values[i];
      const y = v * innerH;
      if (y >= state.peaks[i]) {
        state.peaks[i] = y;
        state.lastPeakTs[i] = now;
      } else {
        // mantieni per peakHoldMs poi decadi
        if (now - state.lastPeakTs[i] > state.peakHoldMs) {
          state.peaks[i] = Math.max(0, state.peaks[i] - innerH * 0.01); // decay
        }
      }
    }

    // Gradiente barre
    const grad = ctx2d.createLinearGradient(0, padY + innerH, 0, padY);
    grad.addColorStop(0, '#2b2b2b');
    grad.addColorStop(0.35, '#4A90E2');
    grad.addColorStop(1, '#7ab7ff');

    // Disegna barre
    for (let i = 0; i < state.bins; i++) {
      const x = padX + i * barW + gap * 0.5;
      const barHeight = values[i] * innerH;
      const y = padY + innerH - barHeight;
      // barra
      ctx2d.fillStyle = grad;
      const radius = Math.min(10, usableBarW * 0.4);
      roundRect(ctx2d, x, y, Math.max(1, usableBarW), Math.max(2, barHeight), radius);
      ctx2d.fill();

      // peak cap
      ctx2d.fillStyle = 'rgba(0,0,0,.7)';
      const capH = Math.max(3, Math.min(10, usableBarW * 0.6));
      const capY = padY + innerH - state.peaks[i] - capH - 2;
      roundRect(ctx2d, x, capY, Math.max(1, usableBarW), capH, Math.min(6, radius * 0.7));
      ctx2d.fill();
    }

    rafId = requestAnimationFrame(draw);
  }

  function roundRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }

  function startVisualizer() {
    if (!ac) setupAudioGraph();
    if (ac && ac.state === 'suspended') {
      ac.resume().catch(()=>{});
    }
    cancelAnimationFrame(rafId);
    updateFreqMap();
    draw();
  }

  function stopVisualizer() {
    cancelAnimationFrame(rafId);
  }

  // ===== Player logic =====
  function setPlayIcon(playing) {
    playBtn.innerHTML = playing
      ? '<svg class="icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>'
      : '<svg class="icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><polygon points="5,3 19,12 5,21"/></svg>';
  }

  function loadStream(url, label) {
    // reset HLS
    if (hls) { hls.destroy(); hls = null; }
    audio.pause();
    audio.src = '';
    setPlayIcon(false);
    playBtn.disabled = true;
    nowEl.textContent = 'Connessione…';

    // Mantiene le info UI
    titleEl.textContent = label || 'Radio';
    urlEl.textContent = url;

    const play = () =>
      audio.play().then(() => {
        playBtn.disabled = false;
        setPlayIcon(true);
        isPlaying = true;
        nowEl.textContent = 'In riproduzione';
        // attiva/Reattiva visualizer dopo che parte l’audio
        startVisualizer();
      }).catch(err => {
        nowEl.textContent = 'Riproduzione bloccata (clicca Play)';
        playBtn.disabled = false;
        console.warn(err);
      });

    if (/\.m3u8($|\?)/i.test(url)) {
      if (window.Hls && Hls.isSupported()) {
        hls = new Hls({ enableWorker:true, liveSyncDuration: 20, maxBufferLength: 30, backBufferLength: 0 });
        hls.loadSource(url);
        hls.attachMedia(audio);
        hls.once(Hls.Events.MANIFEST_PARSED, play);
        hls.on(Hls.Events.ERROR, (_, data) => {
          if (!data.fatal) return;
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR: hls.startLoad(); break;
            case Hls.ErrorTypes.MEDIA_ERROR: hls.recoverMediaError(); break;
            default: hls.destroy(); nowEl.textContent = 'Errore stream'; break;
          }
        });
      } else if (audio.canPlayType('application/vnd.apple.mpegurl')) {
        audio.src = url;
        audio.addEventListener('loadedmetadata', play, { once: true });
      } else {
        alert('HLS non supportato dal browser.');
        nowEl.textContent = 'HLS non supportato';
      }
    } else {
      audio.src = url;
      play();
    }
  }

  selector.addEventListener('change', () => {
    const opt = selector.options[selector.selectedIndex];
    loadStream(selector.value, opt?.text || 'Radio');
  });

  playBtn.addEventListener('click', async () => {
    if (!selector.value) return;
    try { if (ac && ac.state === 'suspended') await ac.resume(); } catch {}
    if (audio.paused) {
      audio.play().then(() => {
        isPlaying = true;
        setPlayIcon(true);
        nowEl.textContent = 'In riproduzione';
        startVisualizer();
      }).catch(()=>{});
    } else {
      audio.pause();
    }
  });

  audio.addEventListener('play', () => {
    playBtn.disabled = false;
    setPlayIcon(true);
    isPlaying = true;
    nowEl.textContent = 'In riproduzione';
  });
  audio.addEventListener('pause', () => {
    setPlayIcon(false);
    isPlaying = false;
    nowEl.textContent = 'In pausa';
  });
  audio.addEventListener('stalled', () => { nowEl.textContent = 'Buffering…'; });
  audio.addEventListener('waiting', () => { nowEl.textContent = 'Buffering…'; });
  audio.addEventListener('error', () => { nowEl.textContent = 'Errore stream'; });

  // Volume & tilt
  volEl.addEventListener('input', () => {
    audio.volume = parseFloat(volEl.value);
    if (gainNode) gainNode.gain.value = 1; // lasciamo unity; usiamo il volume nativo dell'audio
  });
  tiltEl.addEventListener('input', () => {
    const v = parseFloat(tiltEl.value); // -1..1
    if (biquadTilt) biquadTilt.gain.value = v * 10; // +/- 10 dB sugli alti
  });

  // Riprendi quando si torna alla tab
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && audio.src && !isPlaying) {
      audio.play().catch(()=>{});
    }
  });

  // Primo setup del graph per preparare Analyser (richiede gesture poi resume)
  setupAudioGraph();
})();
</script>
